% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiseed_vim.R
\name{multiseed_vim}
\alias{multiseed_vim}
\title{Estimate variable importance with multiple seeds}
\usage{
multiseed_vim(
  n_seed,
  agg_method = "compound_bg",
  ci_grid,
  type,
  time,
  event,
  X,
  landmark_times = stats::quantile(time[event == 1], probs = c(0.25, 0.5, 0.75)),
  restriction_time = max(time[event == 1]),
  approx_times = NULL,
  large_feature_vector,
  small_feature_vector,
  conditional_surv_generator = NULL,
  conditional_surv_generator_control = NULL,
  large_oracle_generator = NULL,
  large_oracle_generator_control = NULL,
  small_oracle_generator = NULL,
  small_oracle_generator_control = NULL,
  cf_fold_num = 5,
  sample_split = TRUE,
  scale_est = FALSE,
  alpha = 0.05,
  verbose = FALSE
)
}
\arguments{
\item{n_seed}{Number of iterations (seeds) to perform the VIM estimation procedure. These will be aggregated into a single result.}

\item{agg_method}{P-value aggregation method use to combine results from different seeds. Current options are \code{"bonferroni"} (Bonferroni's method),
\code{"hommel"} (Hommel's method), \code{"arithmetic"} (arithmetic mean), \code{"geometric"} (geometric mean), \code{"harmonic"} (harmonic mean),
\code{"compound_bg"} (compound Bonferroni and geometric mean), and \code{"compound_ba"} (compound Bonferroni and arithmetic mean). These approaches
are discussed at length in Vovk and Wang (2020). Defaults to \code{"compound_bg"}, which has been shown to work well in many settings.}

\item{ci_grid}{Grid of VIM values over which to construct a confidence interval by inverting a hypothesis test. The aggregation works by constructing
hypothesis tests (at level \code{alpha}) of the null corresponding to each value in \code{ci_grid}, and then inverting these tests to yield a
1 - \code{alpha} confidence interval. For example, for \code{"AUC"} importance, the VIM takes values in (0,1), so a grid of values between 0 and 1
would be a reasonable choice.}

\item{type}{Type of VIM to compute. Options include \code{"accuracy"}, \code{"AUC"}, \code{"Brier"}, \code{"R-squared"}
\code{"C-index"}, and \code{"survival_time_MSE"}.}

\item{time}{\code{n x 1} numeric vector of observed
follow-up times. If there is censoring, these are the minimum of the
event and censoring times.}

\item{event}{\code{n x 1} numeric vector of status indicators of
whether an event was observed.}

\item{X}{\code{n x p} data.frame of observed covariate values}

\item{landmark_times}{Numeric vector of length J1 giving
landmark times at which to estimate VIM (\code{"accuracy"}, \code{"AUC"}, \code{"Brier"}, \code{"R-squared"}).}

\item{restriction_time}{Maximum follow-up time for calculation of \code{"C-index"} and \code{"survival_time_MSE"}.}

\item{approx_times}{Numeric vector of length J2 giving times at which to
approximate integrals. Defaults to a grid of 100 timepoints, evenly spaced on the quantile scale of the distribution of observed event times.}

\item{large_feature_vector}{Numeric vector giving indices of features to include in the 'large' prediction model.}

\item{small_feature_vector}{Numeric vector giving indices of features to include in the 'small' prediction model. Must be a
subset of \code{large_feature_vector}.}

\item{conditional_surv_generator}{A function to estimate the conditional survival functions of the event and censoring variables. Must take arguments
(\code{time}, \code{event}, \code{X}) (for training purposes) and (\code{X_holdout} and \code{newtimes}) (covariate values and times at which to generate predictions). Defaults to a
pre-built generator function based on the \link{stackG} function. Alternatively, the user can provide their own function for this argument, or provide pre-computed estimates to \code{conditional_surv_preds} in lieu of this argument.}

\item{conditional_surv_generator_control}{A list of arguments to pass to \code{conditional_surv_generator}.}

\item{large_oracle_generator}{A function to estimate the oracle prediction function using \code{large_feature_vector}. Must take arguments
\code{time}, \code{event}, \code{X}, \code{X_holdout}, and \code{nuisance_preds}. Defaults to a pre-built generator function using
doubly-robust pseudo-outcome regression, which we strongly recommend. Alternatively, the user can provide their own function, or provide pre-computed estimates to \code{large_oracle_preds} in lieu of this argument.}

\item{large_oracle_generator_control}{A list of arguments to pass to \code{large_oracle_generator}.}

\item{small_oracle_generator}{A function to estimate the oracle prediction function using \code{small_feature_vector}. Must take arguments
\code{time}, \code{event}, \code{X}, \code{X_holdout}, and \code{nuisance_preds}. Defaults to a pre-built generator function using
doubly-robust pseudo-outcome regression, which we strongly recommend. Alternatively, the user can provide their own function, or provide pre-computed estimates to \code{small_oracle_preds} in lieu of this argument.}

\item{small_oracle_generator_control}{A list of arguments to pass to \code{small_oracle_generator}.}

\item{cf_fold_num}{The number of cross-fitting folds, if not providing \code{cf_folds}. Note that with samples-splitting, the data will be split into \code{2 x cf_fold_num} folds (i.e., there will be \code{cf_fold_num} folds within each half of the data).}

\item{sample_split}{Logical indicating whether or not to sample split. Sample-splitting is required for valid hypothesis testing of null importance and is generally recommended. Defaults to \code{TRUE}.}

\item{scale_est}{Logical, whether or not to force the VIM estimate to be nonnegative.}

\item{alpha}{The level at which to compute confidence intervals and hypothesis tests. Defaults to 0.05.}

\item{verbose}{Whether to print progress messages.}
}
\value{
Named list with the following elements:
\item{agg_result}{Data frame giving results aggregated over seeds.}
\item{agg_method}{P-value aggregation method used.}
\item{n_seed}{Number of iterations (seeds) used to perform the VIM estimation procedure.}
\item{vim_objects}{A list of \code{vim} return objects, each corresponding to a different seed.}
}
\description{
Repeat the VIM estimation procedure multiple times and aggregate the results,
mitigating the additional randomness introduced by sample-splitting and cross-fitting.
}
\details{
Using a larger value of \code{n_seed} will result in more stable results, at a greater computational cost.
}
\examples{
# This is a small simulation example
set.seed(123)
n <- 100
X <- data.frame(X1 = rnorm(n), X2 = rbinom(n, size = 1, prob = 0.5))

T <- rexp(n, rate = exp(-2 + X[,1] - X[,2] + .5 *  X[,1] * X[,2]))

C <- rexp(n, exp(-2 -.5 * X[,1] - .25 * X[,2] + .5 * X[,1] * X[,2]))
C[C > 15] <- 15

time <- pmin(T, C)
event <- as.numeric(T <= C)

# landmark times for AUC
landmark_times <- c(3)

output <- multiseed_vim(n_seed = 2,
              agg_method = "compound_bg",
              ci_grid = seq(0, 1, by = 0.01),
              type = "AUC",
              time = time,
              event = event,
              X = X,
              landmark_times = landmark_times,
              large_feature_vector = 1:2,
              small_feature_vector = 2,
              conditional_surv_generator_control = list(SL.library = c("SL.mean", "SL.glm")),
              large_oracle_generator_control = list(SL.library = c("SL.mean", "SL.glm")),
              small_oracle_generator_control = list(SL.library = c("SL.mean", "SL.glm")),
              cf_fold_num = 2,
              sample_split = TRUE,
              scale_est = TRUE)

print(output$result)

}
\references{
Vovk V. and Wang R. (2020). "Combining p-values via averaging."

Wolock C.J., Gilbert P.B., Simon N., and Carone, M. (2024).
"Assessing variable importance in survival analysis using machine learning."
}
\seealso{
\link{vim}
}
